<!doctype html>
<html lang="ja">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Color Noise</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    body {
      font-family: 'Roboto', sans-serif;
      background-color: #f4f4f9;
      color: #333;
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
    }

    .wrap {
      background: #fff;
      padding: 20px 30px;
      border-radius: 10px;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      max-width: 720px;
      width: 90%;
    }

    h1 {
      font-size: 20px;
      margin: 0 0 12px;
      font-weight: 700;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 140px;
      gap: 12px;
      align-items: end;
      margin: 10px 0;
    }

    label {
      font-size: 12px;
      color: #666;
      display: block;
      margin-bottom: 6px;
    }

    select,
    input[type="number"] {
      width: 100%;
      padding: 10px 12px;
      border-radius: 8px;
      background: #fff;
      color: #333;
      border: 1px solid #ccc;
    }

    .controls {
      display: flex;
      gap: 10px;
      margin-top: 14px;
    }

    button {
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid #ccc;
      background: #fff;
      color: #333;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    button.primary {
      background: #007BFF;
      color: #fff;
      border-color: transparent;
    }

    button:hover {
      background: #f0f0f0;
    }

    button.primary:hover {
      background: #0056b3;
    }

    .status {
      margin-top: 10px;
      font-size: 12px;
      color: #666;
    }

    .credit {
      margin-top: 14px;
      font-size: 11px;
      color: #666;
    }

    a {
      color: #007BFF;
      text-decoration: none;
      transition: color 0.3s ease;
    }

    a:hover {
      color: #0056b3;
    }

    .noise-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 10px;
      margin-bottom: 20px;
    }

    .noise-button {
      padding: 12px;
      border-radius: 8px;
      border: 1px solid #ccc;
      background: #fff;
      color: #333;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .noise-button.active {
      background: #007BFF;
      color: #fff;
      border-color: transparent;
    }

    .noise-button:hover {
      background: #f0f0f0;
    }

    .noise-button.active:hover {
      background: #0056b3;
    }

    .volume-value {
      text-align: right;
      font-size: 12px;
      color: #666;
    }

    input[type="range"] {
      width: 100%;
      margin: 0;
    }

    .hint {
      font-size: 11px;
      opacity: 0.7;
      margin-left: 4px;
    }

    @media (prefers-color-scheme: dark) {
      body {
        background-color: #121212;
        color: #e0e0e0;
      }

      .wrap {
        background: #1e1e1e;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
      }

      select,
      input[type="number"] {
        background: #2d2d2d;
        color: #e0e0e0;
        border-color: #404040;
      }

      button {
        background: #2d2d2d;
        color: #e0e0e0;
        border-color: #404040;
      }

      button:hover {
        background: #3d3d3d;
      }

      button.primary {
        background: #80bfff;
        color: #121212;
      }

      button.primary:hover {
        background: #4da6ff;
      }

      label,
      .status,
      .credit {
        color: #999;
      }

      a {
        color: #80bfff;
      }

      a:hover {
        color: #4da6ff;
      }

      .noise-button {
        background: #2d2d2d;
        color: #e0e0e0;
        border-color: #404040;
      }

      .noise-button:hover {
        background: #3d3d3d;
      }

      .noise-button.active {
        background: #80bfff;
        color: #121212;
      }

      .noise-button.active:hover {
        background: #4da6ff;
      }

      .volume-value {
        color: #999;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <h1>カラーノイズ再生</h1>

    <div class="noise-grid" id="noise-grid">
      <button class="noise-button active" data-noise="white">ホワイトノイズ</button>
      <button class="noise-button" data-noise="pink">ピンクノイズ</button>
      <button class="noise-button" data-noise="brown">ブラウニアンノイズ</button>
      <button class="noise-button" data-noise="blue">ブルーノイズ</button>
      <button class="noise-button" data-noise="purple">パープルノイズ</button>
      <button class="noise-button" data-noise="gray">グレイノイズ</button>
    </div>

    <div class="row">
      <div>
        <label for="volume">音量</label>
        <input type="range" id="volume" min="0" max="100" value="30">
      </div>
      <div class="volume-value">30%</div>
    </div>

    <div class="row">
      <div>
        <label for="minutes">再生時間</label>
        <select id="minutes">
          <option value="">無制限</option>
          <option value="15">15分</option>
          <option value="30">30分</option>
          <option value="60">60分</option>
        </select>
      </div>
    </div>

    <div class="controls">
      <button id="start" class="primary">再生</button>
      <button id="stop">停止</button>
    </div>

    <div class="status" id="status">停止中</div>
  </div>

  <script>
    (() => {
      class NoiseGenerator {
        constructor(context) {
          this.context = context;
          this.node = this.context.createScriptProcessor(4096, 1, 1);
          this.type = 'white';
          this.lastOutput = 0;
          this.pinkNoise = { b0: 0, b1: 0, b2: 0, b3: 0, b4: 0, b5: 0, b6: 0 };
        }

        reset() {
          this.lastOutput = 0;
          this.pinkNoise = { b0: 0, b1: 0, b2: 0, b3: 0, b4: 0, b5: 0, b6: 0 };
        }

        setType(type) {
          this.type = type;
          this.reset();
        }

        process(e) {
          const output = e.outputBuffer.getChannelData(0);

          switch (this.type) {
            case 'white':
              for (let i = 0; i < output.length; i++) {
                output[i] = (Math.random() * 2 - 1) * 0.5;
              }
              break;

            case 'pink': {
              const p = this.pinkNoise;
              for (let i = 0; i < output.length; i++) {
                const white = Math.random() * 2 - 1;
                p.b0 = 0.99886 * p.b0 + white * 0.0555179;
                p.b1 = 0.99332 * p.b1 + white * 0.0750759;
                p.b2 = 0.96900 * p.b2 + white * 0.1538520;
                p.b3 = 0.86650 * p.b3 + white * 0.3104856;
                p.b4 = 0.55000 * p.b4 + white * 0.5329522;
                p.b5 = -0.7616 * p.b5 - white * 0.0168980;
                output[i] = (p.b0 + p.b1 + p.b2 + p.b3 + p.b4 + p.b5 + p.b6 + white * 0.5362) * 0.11;
                p.b6 = white * 0.115926;
              }
              break;
            }

            case 'brown':
              for (let i = 0; i < output.length; i++) {
                const white = Math.random() * 2 - 1;
                this.lastOutput = (this.lastOutput + (0.016 * white)) / 1.016;
                output[i] = this.lastOutput * 3.0;  // 3.5 -> 3.0に調整
              }
              break;

            case 'blue':
              for (let i = 0; i < output.length; i++) {
                const white = Math.random() * 2 - 1;
                this.lastOutput = 0.98 * this.lastOutput + white;
                output[i] = (white - this.lastOutput) * 0.05;  // 0.5 -> 0.05に調整
              }
              break;

            case 'purple':
              for (let i = 0; i < output.length; i++) {
                const white = Math.random() * 2 - 1;
                const highFreq = white - this.lastOutput;
                this.lastOutput = white;
                output[i] = (highFreq + this.lastOutput * 0.8) * 0.25;  // 0.35 -> 0.25に調整
              }
              break;

            case 'gray':
              for (let i = 0; i < output.length; i++) {
                let sum = 0;
                for (let j = 0; j < 6; j++) {
                  sum += Math.random() * 2 - 1;
                }
                output[i] = (sum / 6) * 0.5;
              }
              break;
          }
        }
      }

      const sel = document.getElementById('noise-grid');
      const noiseButtons = sel.querySelectorAll('.noise-button');
      const minutesInput = document.getElementById('minutes');
      const startBtn = document.getElementById('start');
      const stopBtn = document.getElementById('stop');
      const statusEl = document.getElementById('status');
      const volumeSlider = document.getElementById('volume');
      const volumeValue = document.querySelector('.volume-value');

      let wakeLock = null;
      let audioContext = null;
      let gainNode = null;
      let noiseGenerator = null;
      let currentGenerator = null;  // 現在のジェネレーター
      let endAt = null;
      let ticker = null;
      let isInitialized = false;
      let pressTimer = null;

      function cleanupAudio() {
        if (noiseGenerator) {
          noiseGenerator.node.disconnect();
          noiseGenerator = null;
        }
        if (gainNode) {
          gainNode.disconnect();
          gainNode = null;
        }
        if (audioContext) {
          audioContext.close();
          audioContext = null;
        }
        isInitialized = false;
      }

      function initAudio() {
        cleanupAudio();
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        gainNode = audioContext.createGain();
        noiseGenerator = new NoiseGenerator(audioContext);
        currentGenerator = noiseGenerator;  // 現在のジェネレーターを設定
        noiseGenerator.node.connect(gainNode);
        gainNode.connect(audioContext.destination);
        noiseGenerator.node.onaudioprocess = (e) => noiseGenerator.process(e);
        gainNode.gain.setValueAtTime(0, audioContext.currentTime);
        isInitialized = true;
      }

      function updateStatus() {
        if (!audioContext || audioContext.state === 'suspended') {
          statusEl.textContent = "停止中";
          return;
        }
        if (endAt) {
          const remainMs = Math.max(0, endAt - Date.now());
          const m = Math.floor(remainMs / 60000);
          const s = Math.floor((remainMs % 60000) / 1000);
          statusEl.textContent = `再生中 · 残り ${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}`;
        } else {
          statusEl.textContent = "再生中 · 無制限";
        }
      }

      function start() {
        initAudio();

        const activeButton = sel.querySelector('.noise-button.active');
        noiseGenerator.setType(activeButton.dataset.noise);

        const mins = parseFloat(minutesInput.value);
        endAt = Number.isFinite(mins) && mins > 0 ? Date.now() + mins * 60000 : null;

        if ('wakeLock' in navigator) {
            navigator.wakeLock.request('screen').then(lock => {
                wakeLock = lock;
            }).catch(err => console.warn('WakeLock error:', err));
        }

        // フェードイン
        const volume = volumeSlider.value / 100;
        const now = audioContext.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(volume, now + 0.5);

        if (ticker) clearInterval(ticker);
        ticker = setInterval(() => {
            if (endAt && Date.now() >= endAt) {
                stop();
                return;
            }
            updateStatus();
        }, 16);

        updateStatus();
      }

      function stop() {
        if (ticker) clearInterval(ticker);
        ticker = null;
        endAt = null;

        if (wakeLock) {
            wakeLock.release().then(() => {
                wakeLock = null;
            });
        }

        if (audioContext) {
            const now = audioContext.currentTime;
            gainNode.gain.setValueAtTime(gainNode.gain.value, now);
            gainNode.gain.linearRampToValueAtTime(0, now + 0.5);

            setTimeout(() => {
                cleanupAudio();
                updateStatus();
            }, 600);
        }
      }

      function updateVolume() {
        if (!gainNode) return;
        const volume = volumeSlider.value / 100;
        volumeValue.textContent = `${volumeSlider.value}%`;
        gainNode.gain.setValueAtTime(volume, audioContext?.currentTime || 0);
      }

      volumeSlider.addEventListener('input', updateVolume);

      startBtn.addEventListener('click', () => {
        try {
          start();
        } catch (error) {
          console.error('Audio start error:', error);
          statusEl.textContent = "エラー: 音声の開始に失敗しました";
        }
      });

      stopBtn.addEventListener('click', stop);

      // ノイズボタンのイベントリスナー
      noiseButtons.forEach(btn => {
        btn.addEventListener('click', () => {
          noiseButtons.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          
          if (noiseGenerator && audioContext) {
            const now = audioContext.currentTime;
            const currentVolume = gainNode.gain.value;
            const crossFadeDuration = 1.0; // クロスフェードの時間（秒）
            
            // 新しいノイズジェネレーターとゲインノードを作成
            const newGenerator = new NoiseGenerator(audioContext);
            const newGain = audioContext.createGain();
            newGenerator.setType(btn.dataset.noise);
            newGenerator.node.connect(newGain);
            newGain.connect(audioContext.destination);
            newGenerator.node.onaudioprocess = (e) => newGenerator.process(e);
            
            // 古いゲインをフェードアウト
            gainNode.gain.setValueAtTime(currentVolume, now);
            gainNode.gain.linearRampToValueAtTime(0, now + crossFadeDuration);
            
            // 新しいゲインをフェードイン
            newGain.gain.setValueAtTime(0, now);
            newGain.gain.linearRampToValueAtTime(currentVolume, now + crossFadeDuration);
            
            // クロスフェード完了後に古いノイズを切断
            setTimeout(() => {
              if (currentGenerator) {
                currentGenerator.node.disconnect();
                gainNode.disconnect();
              }
              currentGenerator = newGenerator;
              gainNode = newGain;
            }, crossFadeDuration * 1000);
            
            noiseGenerator = newGenerator;
          }
        });
      });

      // クレジット表示を削除
      const creditEl = document.getElementById('credit');
      creditEl.remove();

      window.addEventListener('unload', cleanupAudio);
    })();
    </script>
    </body>
</html>